
В первых двух задачах упущена из виду часть условия:

> Ваша задача - реализовать класс GameSavingLoader с методом load, который загружает данные (с помощью функции read), парсит их (с помощью функции json()) __и создаёт объект типа GameSaving.__

Вам нужно создать класс GameSaving описать его согласно спецификации из условия, затем вернуть экземпляр этого класса из метода `load()`

Также в первом, в методе `load()` ДЗ можно обойтись без обёртки Promise. Почитайте, что конкретно возвращает метод `then()`.

Папка с тестами должна называться `__tests__`. Это имя указано в маске регулярного выражения jest по умолчанию.
https://jestjs.io/docs/27.x/configuration#testmatch-arraystring
![](https://u.netology.ru/backend/uploads/markdown_images/image/125229/image.png)
Чаще обращайтесь к документации на библиотеки, что используете. 




Итератор достаточно частая штука в логике языка. И это можно использовать.

Например Set может вернуть итератор, достаточно немного изучить документацию. 
![](https://u.netology.ru/backend/uploads/markdown_images/image/125236/image.png)

А если это так, значит можно без зазрения совести использовать его.
![](https://u.netology.ru/backend/uploads/markdown_images/image/125237/image.png)

Причём и с массивами тоже.
![](https://u.netology.ru/backend/uploads/markdown_images/image/125238/image.png)

А с генераторами ещё интереснее:
![](https://u.netology.ru/backend/uploads/markdown_images/image/125239/image.png)

И это возможно потому что:
![](https://u.netology.ru/backend/uploads/markdown_images/image/125240/image.png)


Ещё первую задачу можно решить так:

```javascript
function getOrderedProps(obj, filter) {
  const filterAndSortObjProperties = Object.keys(obj)
    .filter(key => !filter.includes(key))
    .sort()
  
  return filter
    .concat(filterAndSortObjProperties)
    .map(key => ({
    key, value: obj[key] 
  }))
  
}
```

Почему бы просто не написать так:
```javascript
function getHealth({health}) {
  if(health <= 15) {
    return 'critical'
  }
  if(health <= 50) {
    return 'wounded'
  }
  return 'healthy'
}
```

Коллбэк сортировки можно просто написать так, без тернарки:
```javascript
function sortPlayers(players) {
  return [...players].sort((a, b) => b.health - a.health);
}
```

А если использовать ещё и стрелочную функцию, то это становится до смешного просто. 
```javascript
const sortPlayers = players => [...players].sort((a, b) => b.health - a.health);
}
```
Не забывайте делать, хотябы не глубокую копию исходных данных, чтобы не мутировать их. Мы же хотим получить сортировку какого-то массива, а не отсортировать его с концами) 


1. Сохранить список ключех исходного объекта (Object.keys)
2. Отфильтровать ключи, которые не нужно сортировать на дубликаты с массивом из параметров (Array.prototype.filter) 
3. Отсортировать ключи, которые нужно сортировать: (Array.prototype.sort)
4. Объединить массив (sort, alphaberSort), пройтись по нему (Array.prototype.map) и дать ответ



Я написал небольшой пример, как это можно сделать:
https://replit.com/@TomuraCreator/dragndrop


*Visa:*
Регулярное выражение: ^4[0-9]{12}(?:[0-9]{3})?$
Описание: Номер карты Visa начинается с 4 и имеет длину 13 или 16 цифр.
*Mastercard:*
Регулярное выражение: ^5[1-5][0-9]{14}$
Описание: Номер карты Mastercard начинается с 5 и имеет длину 16 цифр.
*American Express:*
Регулярное выражение: ^3[47][0-9]{13}$
Описание: Номер карты American Express начинается с 34 или 37 и имеет длину 15 цифр.
*Discover:*
Регулярное выражение: ^6(?:011|5[0-9]{2})[0-9]{12}$
Описание: Номер карты Discover начинается с 6011, 65 или с 644-649 и имеет длину 16 цифр.
*JCB:*
Регулярное выражение: ^35[0-9]{14}$
Описание: Номер карты JCB начинается с 35 и имеет длину 16 цифр.



Для этой функции ничего не нужно делать кроме как проверять ник на соответствие регулярки и возвращать булево значение.

Вот представьте вы начинаете использовать эту вашу функцию в работе, пытаетесь проверить ник (для удобства представим, что ник принимаем аргументом статического метода).
```
if(Validator.nickVaditadator("11dsdsd22")) {
	// do smth...
}
```

Всё, ваша программа закончилась) Код лёг, потому что он синициировал ошибку, которая просто ложит ваш клиент. Сайтом теперь пользоваться нельзя.

Вы мне парируете, но можно же написать try catch и отловить ошибку. Да, можно, и это действительно будет работать. 

```
let passNickname = false; 
try {
	passNickname = Validator.nickVaditadator("11dsdsd22")
} catch(e) {
	passNickname = false;
}
if(passNickname) {
	// do smth... 
}
```

Мы увеличили код, теперь конструкция получилась не очень читаемой, а если начнём туда добавлять ещё логику, то это превратится в неподдерживаемую кашу. И, вот так, теперь вы будете писать везде, где вам захочется использовать эту функцию валидации никнейма. Круто, да? 

А могли просто написать вот так:

```
export default class Validator {
	constructor(name) {
		this.data = { names: name };
	}

	validateUsername() {
		return (/(^[a-zA-Z])([a-zA-Z_\-]+[0-9]{0,3})([a-zA-Z]$)/gi).test(this.data.names);
	}
}
```
