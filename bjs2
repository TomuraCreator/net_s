Аркадий, здравствуйте!

Спасибо за Вашу работу и вопросы.

В первом задании всё верно, но объявление переменной и её инициализацию можно совместить
![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/7790/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)

Во втором задании давайте разбираться.
У нас есть множество, которое можно обойти в цикле - индексный массив. И у нас есть длина этого массива. 
Значит создаём цикл который работает `messages.lenght` раз 
![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/7791/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)
Обратите внимание, что условие цикла не должно иметь знак "меньше или равно", потому как начиная с нуля мы досчитаем до 4 включительно. Но последний индекс массива равен размер массива -1. На запрос `messages[4]` вы получите `undefined`, что говорит нам об отсутствии элемента под индексом 4.
Поэтому условие цикла д.б. `i < messages.lenght` или, если хотите  `i <= messages.lenght - 1`

Так как мы знаем, что каждую итерацию цикла тело цикла обновляется, а нам нужна структура, чтобы пользоваться ей и после цикла, создаём переменную с массивом в глобальной области видимости. 
![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/7792/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)

Теперь нам нужно создать в теле цикла новый объект наполнить его данными из массива messages и запушить (добавить новый элемент) в наш новый массив. Так как на каждой итерации контекст внутри тела цикла обновляется мы каждый раз будем получать новый объект. А раз это цикл со счётчиком, счётчик будет каждый раз указывать на новый элемент нашего исходного массива и данные тоже будут разные.

Если выразить это псевдокодом будет так
![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/7793/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)

Сейчас вы создали массив и в цикле добавляете ему __свойства__. Ради эксперимента выведите в консоль весь новый массив, чтобы посмотреть как много данных осталось после цикла. 
Ноша задача обойти весь исходный многомерный массив. В теле цикла создать новый объект. Записать ему свойства которым к=будут соответствовать данные подмассива.
А потом добавить в новый массив этот объект как элемент. Не как свойство.


Наша задача перебрать в цикле исходный многомерный массив. На каждой итерации цикла нужно создать объект. Добавить объекту свойства author и text. Присвоить свойствам первый и второй элемент подмассива соответственно. 

```
{
	author: messages[][0],
	text: messages[][1]
}
```
Добавить объект в новый массив в глобальной области видимости.

В третьей задаче, для примера и в качестве подсказки, проследите цепочку до свойства `"mama"` 
![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/7795/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)
а вы пытаетесь получить длину 'undefined' потому как свойства wife в объекте user нет. 
https://yadi.sk/i/B6fGPjlYXnYjfw
Чему следует закономерная ошибка 
![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/7798/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)
@Ошибка типа: невозможно прочесть свойство `lenght` из undefined.
Потому как исходя их описания в документации undefined является примитивом у которого нет свойств и методов 
![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/7800/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)

Управляющий символ переноса каретки на новую строку не совсем соответствует форматированию сообщения по условию задачи 
![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/7796/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)



Вы правильно начали с цикла. Теперь, при помощи счётчика цикла мы выделим из массива сущности текст и автор. У вас уже есть эта часть в коде, но вы просто перебираете многомерный массив и выводите в консоль. Мы же будем сохранять эти сущности в объект или в переменные. 
Способов, как это можно сделать, много. Начнём с самого банального, создание переменных:

![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/73083/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)
Создали 2 переменные, в них поместили данные из подмассивов. Записали их в объект. JS даёт возможность просто написать имя переменной через запятую в фигурных скобках, так будет создан объект именем  свойства выступит имя переменной, а значением - значение переменной.

Можно произвести деструктуризацию массива на подмассиве:
![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/73086/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)
Здесь массив справа от присваивания, как бы разрушается на порядковые части, где они присваиваются в переменные слева от знака присваивания по порядку. 0 элемент в author, 1 - text. Создание объекта без изменения.

Можно сначала создать пустой объект, после чего наполнить его свойствами. 
![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/73089/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)
Помним, если указанного свойства в объекте нет, оно создаётся, если есть - его значение перезаписывается.

а можно объявить создание объекта с инициализацией полей:
![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/73090/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)

Всё тоже самое, что и предыдущий пример, только свойства создаются и инициализируются сразу при создании объекта и выделении ему памяти. 

А можно не помещать объект в переменную а сразу при создании кидать его на вход функции. Например `console.log`.
![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/73092/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)

Теперь остаётся только добавить объект в массив написать другой цикл ниже и в нём перебрать с выводом на консоль новый массив объектов.

[Здесь](https://replit.com/@TomuraCreator/Assotsiativnyi-massiv2#index.js) все примеры выше.




Правда в задаче 2 лучше всего проверять новую структуру не в том же цикле, где происходит её создание, а в другом цикле. Так вы убережете себя от потери данных, например при перетирании свойств.

В третьей задаче тоже нет ошибок, но код можно сделать чуть чище, если присвоить длинную цепочку свойств в переменную, и использовать её имя. 

![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/12477/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)

Или использовать деструктуризацию объекта. 
![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/12478/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)


Вот здесь вы правильно сделали, что выделили данные через длинную нотацию в переменную, чтобы потом не увеличить строку вывода в консоль. Но это можно сделать [короче и лаконичнее](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/7934/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)





Во второй задаче лучше всего проверять новую структуру не в том же цикле, где происходит её создание, а в другом цикле. Так вы убережете себя от потери данных, например при перетирании свойств.

Хорошая работа. Поздравляю с зачётом и успехов в дальнейшем обучении) 






В третьей задаче требуется через точечную нотацию установить свойство chats для объекта user. Инициализировать в качестве значения объект.
```
user.chats = {} 
```

в который потом записать массив сообщений из задания.

```
user.chats.nameOfChat = [...]
```
В цикле же нужно вывести на консоль один из чатов.






Очень хорошая работа над ошибками. °‿‿°
А раз всё работает, цель выполнена. Но код мы пишем для человека, а чтобы самому в дальнейшем было проще, можно немного упростить код.

В третьей задаче вы хорошо начали, вижу было желание присвоить переменной ссылку и потом пользоваться переменной. Так и нужно. Только в цепочке ссылок пропустили `chats`, да и лучше было использовать переменную с названием чата и дальше.

![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/16900/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)

![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/16902/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)

Но, вообще, присвоение через нотацию квадратных скобок в свойство объекта обычно используется, когда имя свойства заранее не известно, т.е. из какого-нибудь массива или из другого набора данных. В обычных условиях для свойств используют точечную нотацию. 
Вместо этого `chats["mama"].text`, лучше написать так `chats.mama.text` - так читается проще, ибо меньше символьных конструкций. 
Так же в этой задаче можно использовать деконструкцию объекта. Прочтите в интернете) 

В задаче 2 вместо построчного присвоения через точку, можно использовать присвоение с инициализацией. Компьютеру без разницы, а нам проще писать и читать) В нашем случае даже опустить присвоение, а сразу инициализировать в параметры метода, потому что наша переменная с объектом только для этого и нужна

![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/16903/%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)

Поздравляю с зачётом и успехов в дальнейшем обучении) Если остались вопросы, пишите) 








Нужно внести доработки. Если возникнут вопросы, пишите в слак @Vladislav Utkin или телеграм @tomuraKinley 
